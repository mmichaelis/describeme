<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AbstractStreamDescriber.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Core</a> &gt; <a href="index.source.html" class="el_package">com.github.mmichaelis.describeme.core</a> &gt; <span class="el_source">AbstractStreamDescriber.java</span></div><h1>AbstractStreamDescriber.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2015 Mark Michaelis
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.github.mmichaelis.describeme.core;

import static com.github.mmichaelis.describeme.core.AppendableUtil.silentAppend;
import static java.util.Objects.requireNonNull;

import com.google.common.base.MoreObjects;

import com.github.mmichaelis.describeme.core.config.StreamDescriberConfiguration;

import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.function.BiConsumer;
import java.util.stream.Stream;

/**
 * &lt;p&gt;
 * Recurse into streams to describe their elements. If you have any structure which could
 * be transformed to a stream this is the recommended base class to use for your Describer.
 * &lt;/p&gt;
 * &lt;p&gt;
 * It automatically handles maximum depth and maximum count if requested, thus if limited.
 * The only thing to do when implementing is to implement {@link #valueAsStream(Object)}.
 * &lt;/p&gt;
 *
 * @since 1.0.0
 */
<span class="pc bpc" id="L45" title="1 of 2 branches missed.">public abstract class AbstractStreamDescriber implements RecursiveDescriber {</span>

  /**
   * Configuration for the stream describer.
   *
   * @since 1.0.0
   */
  @NotNull
  private final StreamDescriberConfiguration configuration;

  /**
   * Constructor configuring the stream describer behavior.
   *
   * @param configuration some configuration about start and end marker as well as element
   *                      separator
   * @since 1.0.0
   */
<span class="fc" id="L62">  protected AbstractStreamDescriber(@NotNull StreamDescriberConfiguration configuration) {</span>
<span class="fc" id="L63">    this.configuration = requireNonNull(configuration, &quot;configuration must not be null.&quot;);</span>
<span class="fc" id="L64">  }</span>

  /**
   * {@inheritDoc}
   * &lt;p&gt;
   * Value must be convertible to a stream. Stream elements will be sequentially added
   * to the appendable, separated by commas and surrounded by square brackets.
   * &lt;/p&gt;
   *
   * @since 1.0.0
   */
  @Override
  @Contract(&quot;null, _, _, _ -&gt; fail; _, _, _, null -&gt; fail&quot;)
  public final void describeTo(@NotNull Appendable appendable, @Nullable Object value,
                               int maxCount,
                               @NotNull BiConsumer&lt;Object, Object&gt; recursiveMeAndOtherConsumer) {
<span class="fc" id="L80">    requireNonNull(appendable, &quot;appendable must not be null.&quot;);</span>
<span class="fc" id="L81">    validatedValue(value);</span>
<span class="pc bpc" id="L82" title="2 of 4 branches missed.">    assert value != null : &quot;validateValue should have prevented null value.&quot;;</span>
<span class="fc" id="L83">    Stream&lt;?&gt; stream = valueAsStream(value);</span>
<span class="fc" id="L84">    silentAppend(appendable, configuration.startMarker());</span>
<span class="fc" id="L85">    stream.allMatch(new EllipsisPredicate(appendable, value, maxCount, recursiveMeAndOtherConsumer,</span>
<span class="fc" id="L86">                                          configuration.elementSeparator()));</span>
<span class="fc" id="L87">    silentAppend(appendable, configuration.endMarker());</span>
<span class="fc" id="L88">  }</span>

  @Override
  public String toString() {
<span class="nc" id="L92">    return MoreObjects.toStringHelper(this)</span>
<span class="nc" id="L93">        .add(&quot;configuration&quot;, configuration)</span>
<span class="nc" id="L94">        .toString();</span>
  }

  /**
   * &lt;p&gt;
   * Provide the values to describe as stream.
   * &lt;/p&gt;
   *
   * @param value value to convert to a stream
   * @return stream
   * @since 1.0.0
   */
  @NotNull
  @Contract(&quot;null -&gt; fail&quot;)
  protected abstract Stream&lt;?&gt; valueAsStream(@NotNull Object value);
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>